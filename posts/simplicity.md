# Exercises in Simplicity

The more time I spent on software development, the more I come to appreciate simplicity. When software is buggy, slow or lacking features, that is annoying. But as long as it is simple, I can still understand the limitations and work around them or even fix them. When something goes wrong in a complex program, it is often not worth spending the huge amount of time necessary to even understand what is happening. Instead of learning about the problem your software solves, you are drowned in build tools, pre- and post-processors, too many layers of abstractions, many different APIs and huge amounts of dependencies.

Dealing with simpler software is more satisfying for me and provides a faster way to deep understanding. On these pages I want to create an overview of the different ways I approach simple software. Sometimes, I want to replace a program I use by something simpler, in other cases I just want to try something to learn how much of the complexity of common solutions is really necessary.

## Guidelines

* If I start with something very simple, complexity is going to increase over time. I must take care that it does so slowly and that I remove parts that are not necessary, anymore.
* Usability must not suffer too much
* Simplicity is more important than features

## Exercises

* [This web site itself](web.html)
* Vim instead of IDE (see [my vim config](https://github.com/karlb/dotfiles/tree/master/.vim))
* [Use suckless software on my desktop](suckless-desktop.html)
* [Hacking on a minimal markdown-like parser](smu.html)

## Inspiration

* [A Plea for Lean Software](https://inf.ethz.ch/personal/wirth/Articles/LeanSoftware.pdf)
* [Suckless Philosophy](https://suckless.org/philosophy/)
* [A Philosophy of Software Design](https://www.goodreads.com/en/book/show/39996759)

## Quotes

Controlling complexity is the essence of computer programming.

-- Brian Kernighan

Simplicity is prerequisite for reliability.

-- Edsger W. Dijkstra

A program is like a poem: you cannot write a poem without writing it. Yet people talk about programming as if it were a production process and measure "programmer productivity" in terms of "number of lines of code produced". In so doing they book that number on the wrong side of the ledger: We should always refer to "the number of lines of code spent".

-- E. W. Dijkstra
